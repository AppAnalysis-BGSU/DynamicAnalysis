package com.bugsense.trace;

import android.content.Context;
import android.content.pm.PackageInfo;
import android.os.Build;
import android.os.Build.VERSION;
import android.util.Log;
import com.bugsense.trace.models.CrashMechanism;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.io.Writer;
import java.lang.Thread.UncaughtExceptionHandler;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;

public class BugSenseHandler {
    public static boolean I_WANT_TO_DEBUG = false;
    private static HashMap<String, String> crashExtraData = new HashMap();
    private static ExceptionCallback exceptionCallback = null;
    protected static Context gContext;
    private static boolean isSessionActive = false;
    static String locText = "";
    static String locTicker = "";
    static String locTitle = "";
    protected static int sMinDelay = 0;
    private static boolean sSetupCalled = false;
    private static ActivityAsyncTask<Processor, Object, Object, Object> sTask;

    static class C00681 implements Runnable {
        C00681() {
        }

        public void run() {
            C0069G.UID = Utils.manageUid(BugSenseHandler.gContext);
            if (BugSenseHandler.I_WANT_TO_DEBUG) {
                Log.d(C0069G.TAG, "Crash     URL set to: " + C0069G.URL);
            }
            BugSenseHandler.flush(BugSenseHandler.gContext);
            BugSenseHandler.startSession(BugSenseHandler.gContext);
        }
    }

    private interface Processor {
        boolean beginSubmit();

        void handlerInstalled();

        void submitDone();
    }

    static class C02032 implements Processor {
        C02032() {
        }

        public boolean beginSubmit() {
            return true;
        }

        public void handlerInstalled() {
        }

        public void submitDone() {
        }
    }

    public static void addCrashExtraData(String str, String str2) {
        if (crashExtraData == null) {
            crashExtraData = new HashMap();
        }
        crashExtraData.put(str, Utils.exceedLimitString(str2));
    }

    public static void addCrashExtraMap(HashMap<String, String> hashMap) {
        if (crashExtraData == null) {
            crashExtraData = new HashMap();
        }
        for (Entry entry : hashMap.entrySet()) {
            crashExtraData.put(entry.getKey(), Utils.exceedLimitString((String) entry.getValue()));
        }
    }

    public static void clearCrashExtraData() {
        if (crashExtraData == null) {
            crashExtraData = new HashMap();
        } else {
            crashExtraData.clear();
        }
    }

    public static void closeSession(Context context) {
        isSessionActive = false;
    }

    public static void flush(Context context) {
        Log.i(C0069G.TAG, "Flushing...");
        CrashMechanism.getInstance().sendSavedCrashes(context);
    }

    protected static ExceptionCallback getCallback() {
        return exceptionCallback;
    }

    public static HashMap<String, String> getCrashExtraData() {
        if (crashExtraData == null) {
            crashExtraData = new HashMap();
        }
        return crashExtraData;
    }

    private static void initAndStartSession(Context context, Processor processor, String str, String str2) {
        if (context == null) {
            Log.e(C0069G.TAG, "Context is null!");
            return;
        }
        gContext = context;
        if (str == null || str.length() < 8 || str.length() > 14) {
            throw new IllegalArgumentException("Your BugSense API Key is invalid!");
        }
        C0069G.API_KEY = str;
        installHandler();
        processor.handlerInstalled();
        C0069G.PHONE_MODEL = Build.MODEL;
        C0069G.ANDROID_VERSION = VERSION.RELEASE;
        C0069G.APPID = str2;
        try {
            PackageInfo packageInfo = gContext.getPackageManager().getPackageInfo(gContext.getPackageName(), 0);
            C0069G.APP_VERSION = packageInfo.versionName;
            C0069G.APP_VERSIONCODE = String.valueOf(packageInfo.versionCode);
            C0069G.APP_PACKAGE = packageInfo.packageName;
        } catch (Exception e) {
            Log.e(C0069G.TAG, "Error collecting information about the package!");
            if (I_WANT_TO_DEBUG) {
                e.printStackTrace();
            }
        }
        if (!(!sSetupCalled || sTask == null || sTask.postProcessingDone())) {
            sTask.connectTo(null);
            sTask.connectTo(processor);
        }
        sSetupCalled = true;
        try {
            C0069G.FILES_PATH = gContext.getFilesDir().getAbsolutePath();
        } catch (Exception e2) {
            if (I_WANT_TO_DEBUG) {
                e2.printStackTrace();
            }
        }
        if (C0069G.FILES_PATH == null) {
            Log.e(C0069G.TAG, "G.FILES_PATH GOT NULL!");
            return;
        }
        if (I_WANT_TO_DEBUG) {
            Log.d(C0069G.TAG, "Files Path set to: " + C0069G.FILES_PATH);
        }
        C0069G.HAS_ROOT = Utils.checkForRoot();
        new Thread(new C00681()).start();
    }

    public static void initAndStartSession(Context context, String str, String str2) {
        initAndStartSession(context, new C02032(), str, str2);
    }

    private static void installHandler() {
        Log.i(C0069G.TAG, "Registering default exceptions handler");
        UncaughtExceptionHandler defaultUncaughtExceptionHandler = Thread.getDefaultUncaughtExceptionHandler();
        if (defaultUncaughtExceptionHandler != null && I_WANT_TO_DEBUG) {
            Log.d(C0069G.TAG, "current handler class=" + defaultUncaughtExceptionHandler.getClass().getName());
        }
        if (!(defaultUncaughtExceptionHandler instanceof DefaultExceptionHandler)) {
            Thread.setDefaultUncaughtExceptionHandler(new DefaultExceptionHandler(defaultUncaughtExceptionHandler));
        }
    }

    public static void leaveBreadcrumb(String str) {
        if (C0069G.breadcrumbs == null) {
            C0069G.breadcrumbs = new ArrayList(16);
        }
        if (C0069G.breadcrumbs.size() >= 16) {
            C0069G.breadcrumbs.remove(0);
        }
        C0069G.breadcrumbs.add(str);
        if (I_WANT_TO_DEBUG) {
            Log.i(C0069G.TAG, "BreadCrumb: " + str + " added.");
        }
    }

    public static void removeCrashExtraData(String str) {
        if (crashExtraData == null) {
            crashExtraData = new HashMap();
        }
        crashExtraData.remove(str);
    }

    public static void sendException(Exception exception) {
        sendExceptionMap(new HashMap(0), exception);
    }

    public static void sendExceptionMap(HashMap<String, String> hashMap, Exception exception) {
        Writer stringWriter = new StringWriter();
        PrintWriter printWriter = new PrintWriter(stringWriter);
        if (C0069G.API_KEY == null) {
            Log.e(C0069G.TAG, "Could not send: API Key is missing");
            return;
        }
        Log.i(C0069G.TAG, "Saving handled exception");
        exception.printStackTrace(printWriter);
        Map hashMap2 = new HashMap();
        if (hashMap != null) {
            for (Entry entry : hashMap.entrySet()) {
                hashMap2.put(entry.getKey(), Utils.exceedLimitString((String) entry.getValue()));
            }
        }
        long j = 0;
        try {
            j = System.currentTimeMillis() - C0069G.TIMESTAMP;
        } catch (Exception e) {
        }
        try {
            String createJSONFromCrash;
            exception.printStackTrace(printWriter);
            String str = "";
            try {
                createJSONFromCrash = CrashMechanism.createJSONFromCrash(stringWriter.toString(), Utils.isWifiOn(gContext), Utils.isMobileNetworkOn(gContext), Utils.isGPSOn(gContext), Utils.ScreenProperties(gContext), Utils.getTime(), getCrashExtraData(), hashMap2, 0, j, null);
            } catch (Exception e2) {
                e2.printStackTrace();
                createJSONFromCrash = str;
            }
            CrashMechanism.saveCrash(createJSONFromCrash, 0);
        } catch (Exception e22) {
            Log.e(C0069G.TAG, "Failed to save handled exception ");
            if (I_WANT_TO_DEBUG) {
                e22.printStackTrace();
            }
        }
    }

    public static void sendExceptionMessage(String str, String str2, Exception exception) {
        HashMap hashMap = new HashMap(1);
        if (!(str == null || str2 == null)) {
            hashMap.put(str, Utils.exceedLimitString(str2));
        }
        sendExceptionMap(hashMap, exception);
    }

    public static void setExceptionCallback(ExceptionCallback exceptionCallback) {
        exceptionCallback = exceptionCallback;
    }

    public static void setLocalizedNotification(String str, String str2, String str3) {
        locTicker = str;
        locTitle = str2;
        locText = str3;
    }

    public static void setLogging(int i) {
        C0069G.SEND_LOG = true;
        C0069G.LOG_LINES = i;
    }

    public static void setLogging(int i, String str) {
        C0069G.SEND_LOG = true;
        C0069G.LOG_LINES = i;
        C0069G.LOG_FILTER = str;
    }

    public static void setLogging(String str) {
        C0069G.SEND_LOG = true;
        C0069G.LOG_FILTER = str;
    }

    public static void setLogging(boolean z) {
        C0069G.SEND_LOG = z;
    }

    public static void startSession(Context context) {
        gContext = context;
        installHandler();
        if (!isSessionActive) {
            C0069G.TIMESTAMP = System.currentTimeMillis();
            isSessionActive = true;
        }
    }

    public static void useProxy(boolean z) {
        C0069G.proxyEnabled = z;
    }
}
