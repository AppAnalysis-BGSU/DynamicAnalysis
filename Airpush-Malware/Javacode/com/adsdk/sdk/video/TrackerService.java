package com.adsdk.sdk.video;

import com.adsdk.sdk.Log;
import java.lang.Thread.UncaughtExceptionHandler;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.LinkedList;
import java.util.Queue;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.params.HttpConnectionParams;

public class TrackerService {
    private static Object sLock = new Object();
    private static Queue<TrackEvent> sRetryTrackEvents = new LinkedList();
    private static boolean sStopped;
    private static Thread sThread;
    private static boolean sThreadRunning = false;
    private static Queue<TrackEvent> sTrackEvents = new LinkedList();

    class C00641 implements Runnable {
        C00641() {
        }

        public void run() {
            TrackerService.sStopped = false;
            while (!TrackerService.sStopped) {
                while (TrackerService.hasMoreUpdates() && !TrackerService.sStopped) {
                    TrackEvent event = TrackerService.getNextUpdate();
                    Log.m0d("Sending tracking :" + event.url + " Time:" + event.timestamp + " Events left:" + TrackerService.sTrackEvents.size());
                    if (event != null) {
                        try {
                            URL u = new URL(event.url);
                            Log.m0d("Sending conversion Request");
                            Log.m0d("Perform tracking HTTP Get Url: " + event.url);
                            DefaultHttpClient client = new DefaultHttpClient();
                            HttpConnectionParams.setSoTimeout(client.getParams(), 10000);
                            HttpConnectionParams.setConnectionTimeout(client.getParams(), 10000);
                            try {
                                if (client.execute(new HttpGet(u.toString())).getStatusLine().getStatusCode() != 200) {
                                    TrackerService.requestRetry(event);
                                } else {
                                    Log.m0d("Tracking OK");
                                }
                            } catch (Throwable th) {
                                TrackerService.requestRetry(event);
                            }
                        } catch (MalformedURLException e) {
                            Log.m0d("Wrong tracking url:" + event.url);
                        }
                    }
                }
                if (TrackerService.sStopped || TrackerService.sRetryTrackEvents.isEmpty()) {
                    TrackerService.sStopped = true;
                } else {
                    try {
                        Thread.sleep(30000);
                    } catch (Exception e2) {
                    }
                    synchronized (TrackerService.sLock) {
                        TrackerService.sTrackEvents.addAll(TrackerService.sRetryTrackEvents);
                        TrackerService.sRetryTrackEvents.clear();
                    }
                }
            }
            TrackerService.sStopped = false;
            TrackerService.sThreadRunning = false;
            TrackerService.sThread = null;
        }
    }

    class C00652 implements UncaughtExceptionHandler {
        C00652() {
        }

        public void uncaughtException(Thread thread, Throwable ex) {
            TrackerService.sThreadRunning = false;
            TrackerService.sThread = null;
            TrackerService.startTracking();
        }
    }

    public static void requestTrack(TrackEvent[] trackEvents) {
        synchronized (sLock) {
            for (TrackEvent trackEvent : trackEvents) {
                if (!sTrackEvents.contains(trackEvent)) {
                    sTrackEvents.add(trackEvent);
                }
            }
            Log.m0d("Added track event:" + sTrackEvents.size());
        }
        if (!sThreadRunning) {
            startTracking();
        }
    }

    public static void requestTrack(TrackEvent trackEvent) {
        synchronized (sLock) {
            if (!sTrackEvents.contains(trackEvent)) {
                sTrackEvents.add(trackEvent);
            }
            Log.m0d("Added track event:" + sTrackEvents.size());
        }
        if (!sThreadRunning) {
            startTracking();
        }
    }

    public static void requestRetry(TrackEvent trackEvent) {
        synchronized (sLock) {
            if (!sRetryTrackEvents.contains(trackEvent)) {
                trackEvent.retries++;
                if (trackEvent.retries <= 5) {
                    sRetryTrackEvents.add(trackEvent);
                }
            }
            Log.m0d("Added retry track event:" + sRetryTrackEvents.size());
        }
    }

    private static boolean hasMoreUpdates() {
        boolean hasMore;
        synchronized (sLock) {
            hasMore = !sTrackEvents.isEmpty();
            Log.m0d("More updates:" + hasMore + " size:" + sTrackEvents.size());
        }
        return hasMore;
    }

    private static TrackEvent getNextUpdate() {
        synchronized (sLock) {
            if (sTrackEvents.peek() == null) {
                return null;
            }
            TrackEvent nextTrackEvent = (TrackEvent) sTrackEvents.poll();
            return nextTrackEvent;
        }
    }

    public static void startTracking() {
        synchronized (sLock) {
            if (!sThreadRunning) {
                sThreadRunning = true;
                sThread = new Thread(new C00641());
                sThread.setUncaughtExceptionHandler(new C00652());
                sThread.start();
            }
        }
    }

    public static void release() {
        Log.m12v("release");
        if (sThread != null) {
            Log.m12v("release stopping Tracking events thread");
            sStopped = true;
        }
    }
}
