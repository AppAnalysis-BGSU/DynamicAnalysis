package com.srortn.bsiubt135868;

import android.content.Context;
import android.util.Log;
import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.SocketTimeoutException;
import java.net.UnknownHostException;
import java.util.List;
import java.util.zip.GZIPInputStream;
import javax.net.ssl.SSLPeerUnverifiedException;
import org.apache.http.Header;
import org.apache.http.HeaderElement;
import org.apache.http.HttpEntity;
import org.apache.http.HttpRequest;
import org.apache.http.HttpRequestInterceptor;
import org.apache.http.HttpResponse;
import org.apache.http.HttpResponseInterceptor;
import org.apache.http.NameValuePair;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.entity.UrlEncodedFormEntity;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.entity.HttpEntityWrapper;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.message.BasicHttpResponse;
import org.apache.http.params.BasicHttpParams;
import org.apache.http.params.HttpConnectionParams;
import org.apache.http.protocol.HttpContext;
import org.apache.http.util.EntityUtils;

final class NetworkThread implements Runnable {
    private static final String ENCODING_GZIP = "gzip";
    private static final String HEADER_ACCEPT_ENCODING = "Accept-Encoding";
    final AsyncTaskCompleteListener<String> asyncTaskCompleteListener;
    final Context context;
    final boolean isAddvalues;
    final List<NameValuePair> list;
    final String url;
    final long wait;

    class C01701 implements HttpRequestInterceptor {
        C01701() {
        }

        public void process(HttpRequest request, HttpContext context) {
            if (!request.containsHeader(NetworkThread.HEADER_ACCEPT_ENCODING)) {
                request.addHeader(NetworkThread.HEADER_ACCEPT_ENCODING, NetworkThread.ENCODING_GZIP);
            }
        }
    }

    class C01712 implements HttpResponseInterceptor {
        C01712() {
        }

        public void process(HttpResponse response, HttpContext context) {
            Header encoding = response.getEntity().getContentEncoding();
            if (encoding != null) {
                for (HeaderElement element : encoding.getElements()) {
                    if (element.getName().equalsIgnoreCase(NetworkThread.ENCODING_GZIP)) {
                        response.setEntity(new InflatingEntity(response.getEntity()));
                        return;
                    }
                }
            }
        }
    }

    private static class InflatingEntity extends HttpEntityWrapper {
        public InflatingEntity(HttpEntity wrapped) {
            super(wrapped);
        }

        public InputStream getContent() throws IOException {
            return new GZIPInputStream(this.wrappedEntity.getContent());
        }

        public long getContentLength() {
            return -1;
        }
    }

    public NetworkThread(Context context, AsyncTaskCompleteListener<String> asyncTaskCompleteListener, List<NameValuePair> list, String url, long wait, boolean isAddValues) {
        this.context = context;
        this.asyncTaskCompleteListener = asyncTaskCompleteListener;
        this.list = list;
        this.url = url;
        Util.printDebugLog("Url: " + url);
        this.wait = wait;
        this.isAddvalues = isAddValues;
    }

    public void run() {
        synchronized (this) {
            if (this.wait != 0) {
                try {
                    Util.printDebugLog("Thread is waiting for " + this.wait + " ms.");
                    wait(this.wait);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            if (Util.checkInternetConnection(this.context)) {
                try {
                    if (this.isAddvalues) {
                        this.list.addAll(SetPreferences.setValues(this.context));
                    }
                    HttpPost httpPost = new HttpPost(this.url);
                    Util.printDebugLog("Values: " + this.list);
                    httpPost.setEntity(new UrlEncodedFormEntity(this.list));
                    BasicHttpParams httpParameters = new BasicHttpParams();
                    HttpConnectionParams.setConnectionTimeout(httpParameters, 7000);
                    HttpConnectionParams.setSoTimeout(httpParameters, 7000);
                    DefaultHttpClient httpClient = new DefaultHttpClient(httpParameters);
                    httpClient.addRequestInterceptor(new C01701());
                    httpClient.addResponseInterceptor(new C01712());
                    BasicHttpResponse httpResponse = (BasicHttpResponse) httpClient.execute(httpPost);
                    int code = httpResponse.getStatusLine().getStatusCode();
                    Log.i(IConstants.TAG, "Status Code: " + code);
                    if (code == 200) {
                        String responseString = EntityUtils.toString(httpResponse.getEntity());
                        Util.printDebugLog("Response String:" + responseString);
                        if (!(responseString == null || responseString.equals(""))) {
                            this.asyncTaskCompleteListener.onTaskComplete(responseString);
                            return;
                        }
                    }
                    Log.i(IConstants.TAG, "HTTP response reason: " + httpResponse.getStatusLine().getReasonPhrase());
                } catch (UnknownHostException e2) {
                    Log.d("UnknownHostException Thrown", e2.toString());
                } catch (SocketTimeoutException e3) {
                    Log.d("SocketTimeoutException Thrown", e3.toString());
                } catch (ClientProtocolException e4) {
                    Log.d("ClientProtocolException Thrown", e4.toString());
                } catch (MalformedURLException e5) {
                    System.out.println("Url has caused malford: " + this.url);
                    Log.d("MalformedURLException Thrown", e5.toString());
                } catch (SSLPeerUnverifiedException e6) {
                    Log.d("SSL Exception: ", e6.getMessage());
                } catch (IOException e7) {
                    Log.d("IOException Thrown", e7.toString());
                } catch (Exception iex) {
                    Log.d("Exception Thrown: ", "" + iex.getMessage());
                } catch (Throwable th) {
                }
            }
            this.asyncTaskCompleteListener.onTaskComplete(null);
        }
    }
}
